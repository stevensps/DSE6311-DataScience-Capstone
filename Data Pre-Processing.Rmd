
---
title: "Data Pre-Processing"
author: "Steven S., Ben K., and Chris R."
date: "2025-04-10"
output: html_document
---

```{r}
library(haven)
library(dplyr)
library(tidyr)
library(ggplot2)
library(gtsummary)
library(forcats)
library(naniar)
library(corrplot)
library(stats)
library(stringr)
library(car)
library(reshape2)
library(viridis)
library(GGally)
library(knitr)
library(kableExtra)
library(scales)
library(caret)
library(mice)
library(fastDummies)
library(tidymodels)
library(parallel)
library(janitor)
```


# Import data
```{r}
# Code below imports the data to any person's machine
if (!dir.exists("C:/temp")) {
    dir.create("C:/temp")
} # If statement creates temp folder on machine

zipUrl <- "https://www.cdc.gov/brfss/annual_data/2023/files/LLCP2023XPT.zip"
zipPath <- path.expand("C:/temp/LLCP2023XPT.zip")
if (!file.exists(zipPath)) {
    download.file(zipUrl, destfile = zipPath)
} #Download the file

extractPath <- "C:/temp"
sasFile <- file.path(extractPath, "LLCP2023.XPT") 
if (!file.exists(sasFile)) {
    unzip(zipPath, exdir = extractPath)
}
list.files(extractPath) # Extract, unzip, and make sure file exists

if (file.exists(sasFile)) {
    brfss_raw <- read_xpt(sasFile)
    head(brfss_raw)
} else {
    message("File does not exist, check download or unzip process.")
} # Read file into R after specifying file variable

```

# Column names
```{r}
names(brfss_raw)
```
# Rename variables
```{r}
brfss_subset <- brfss_raw %>%
  select(
    ment14d   = `_MENT14D`,
    menthlth  = `MENTHLTH`,
    hlthpl1   = `_HLTHPL1`,
    persdoc3  = PERSDOC3,
    medcost1  = MEDCOST1,
    checkup1  = CHECKUP1,
    primins1  = PRIMINS1,
    addepev3  = ADDEPEV3,
    acedeprs  = ACEDEPRS,
    decide    = DECIDE,
    exerany2  = EXERANY2,
    pa150r4   = `_PA150R4`,
    sex       = `_SEX`,
    age80     = `_AGE80`,
    race      = `_RACE`,
    educa     = EDUCA,
    employ1   = EMPLOY1,
    marital   = MARITAL,
    incomg1   = `_INCOMG1`,
    numadult  = NUMADULT,
    state     = `_STATE`
  )
```

```{r}
brfss_subset <- brfss_subset %>%
  mutate(
    ment14d = na_if(ment14d, 9)
  )
```

# Drop N/A and Check ment14d
```{r}
brfss_subset <- brfss_subset %>%
  filter(!is.na(ment14d))

table(brfss_subset$ment14d, useNA = "ifany")
```

# Split State into Region - CR
```{r}
region_map <- data.frame(
  state = c(1, 2, 4, 5, 6, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19, 20, 
                 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 
                 37, 38, 39, 40, 41, 44, 45, 46, 47, 48, 49, 50, 51, 53, 54, 
                 55, 56, 66, 72, 78), 
  region = c("South", "West", "West", "South", "West", "West", "Northeast", 
             "South", "South", "South", "South", "West", "West", "Midwest", 
             "Midwest", "Midwest", "Midwest", "South", "Northeast", 
             "South", "Northeast", "Midwest", "Midwest", "South", "Midwest", 
             "West", "Midwest", "West", "Northeast", "Northeast", "West", 
             "Northeast", "South", "Midwest", "Midwest", "South", "West", 
             "Northeast", "South", "West", "South", "South", "West", 
             "Northeast", "South", "West", "South", "Midwest", "West", 
             "Territories", "Territories", "Territories") 
)
#Merge region data into main dataset based on state codes
brfss_subset <- merge(brfss_subset, region_map, by.x = "state", by.y = "state", all.x = TRUE)
brfss_subset$region <- as.factor(brfss_subset$region) #Convert region to factor
```

#############Data Preprocessing#############

# Initial Data Split - CR and SS
```{r}
getwd()
source("calcSplitRatio-3.R")
split_ratio <- calcSplitRatio(df = brfss_subset)

set.seed(42)
trainIndex <- createDataPartition(brfss_subset$ment14d, p=split_ratio, list=FALSE)

train_df <- brfss_subset[trainIndex, ]
test_df <- brfss_subset[-trainIndex, ]
```

# Recode Train
```{r}
train_df <- train_df %>%
  mutate(
    hlthpl1 = na_if(as.numeric(as.character(hlthpl1)), 9),
    
    persdoc3 = na_if(as.numeric(as.character(persdoc3)), 7),
    persdoc3 = na_if(persdoc3, 9),
    
    medcost1 = na_if(as.numeric(as.character(medcost1)), 7),
    medcost1 = na_if(medcost1, 9),
    
    checkup1 = na_if(as.numeric(as.character(checkup1)), 7),
    checkup1 = na_if(checkup1, 9),
    
    primins1 = na_if(as.numeric(as.character(primins1)), 77),
    primins1 = na_if(primins1, 99),
    
    exerany2 = na_if(as.numeric(as.character(exerany2)), 7),
    exerany2 = na_if(exerany2, 9),
    
    pa150r4 = na_if(as.numeric(as.character(pa150r4)), 9)
  )

```

```{r}
 train_df <-  train_df %>%
  mutate(
    educa     = na_if(as.numeric(as.character(educa)), 9),
    
    employ1   = na_if(as.numeric(as.character(employ1)), 9),
    
    marital   = na_if(as.numeric(as.character(marital)), 9),
    
    incomg1   = na_if(as.numeric(as.character(incomg1)), 9),
  )

```

```{r}
 train_df <-  train_df %>%
  mutate(
    menthlth = ifelse(menthlth == 88, 0, menthlth),
    menthlth = na_if(menthlth, 77),
    menthlth = na_if(menthlth, 99))
table(train_df$menthlth)
```

#Check ment14d
```{r}
table(train_df$ment14d, useNA = "ifany")
```

```{r}
train_df <- train_df %>% 
  mutate(
    race = na_if(as.numeric(as.character(race)), 9)
  )
table(train_df$race, useNA = "ifany")
```

# Recode Test
```{r}
test_df <- test_df %>%
  mutate(
    hlthpl1   = na_if(as.numeric(as.character(hlthpl1)), 9),

    persdoc3  = na_if(as.numeric(as.character(persdoc3)), 7),
    persdoc3  = na_if(persdoc3, 9),

    medcost1  = na_if(as.numeric(as.character(medcost1)), 7),
    medcost1  = na_if(medcost1, 9),

    checkup1  = na_if(as.numeric(as.character(checkup1)), 7),
    checkup1  = na_if(checkup1, 9),

    primins1  = na_if(as.numeric(as.character(primins1)), 77),
    primins1  = na_if(primins1, 99),

    exerany2  = na_if(as.numeric(as.character(exerany2)), 7),
    exerany2  = na_if(exerany2, 9),

    pa150r4   = na_if(as.numeric(as.character(pa150r4)), 9)
  )
```

```{r}
test_df <-  test_df %>%
  mutate(
    educa     = na_if(as.numeric(as.character(educa)), 9),
    
    employ1   = na_if(as.numeric(as.character(employ1)), 9),
    
    marital   = na_if(as.numeric(as.character(marital)), 9),
    
    incomg1   = na_if(as.numeric(as.character(incomg1)), 9),
  )
```

```{r}
test_df <-  test_df %>%
  mutate(
    menthlth = ifelse(menthlth == 88, 0, menthlth),
    menthlth = na_if(menthlth, 77),
    menthlth = na_if(menthlth, 99))
table(test_df$menthlth)
```

# Check ment14d
```{r}
table(test_df$ment14d, useNA = "ifany")
```

```{r}
test_df <- test_df %>% 
  mutate(
    race = na_if(as.numeric(as.character(race)), 9)
  )
table(test_df$race, useNA = "ifany")
```
############################ encoding categorical values ############################

# Training Set Encoding Categorical Values
```{r}
# Clean variable names BK
train_df <- train_df %>% clean_names()

## binary variables (0=no, 1=yes)
train_df <- train_df %>%
  mutate(
    hlthpl1 = ifelse(hlthpl1 == 1, 1, 0),      # Health plan coverage
    persdoc3 = ifelse(persdoc3 == 1, 1, 0),    # Personal doctor
    medcost1 = ifelse(medcost1 == 1, 1, 0),    # Could not see doctor due to cost
    exerany2 = ifelse(exerany2 == 1, 1, 0),    # Physical activity
    addepev3 = ifelse(addepev3 == 1, 1, 0),    # Ever told you had depressive disorder
    acedeprs = ifelse(acedeprs == 1, 1, 0),    # ACE: depression exposure
    decide = ifelse(decide == 1, 1, 0),        # Decision-making difficulty (cognitive decline)
    pa150r4 = ifelse(pa150r4 == 1, 1, 0)       # Met physical activity guidelines
  )

## ordinal variables (ordered factor)
train_df <- train_df %>%
  mutate(
    educa = factor(educa, levels = c(1:6), ordered = TRUE),            # Education level
    incomg1 = factor(incomg1, levels = 1:8, ordered = TRUE),           # Income group
    checkup1 = factor(checkup1, levels = c(4,3,2,1), ordered = TRUE),  # Last checkup (4 = Never → 1 = <1 year)
    marital = factor(marital, levels = c(5,6,3,4,1,2), ordered = TRUE),# Marital status, loosely ordered
    age80 = as.numeric(age80)                                          # Continuous, but sometimes treated as ordinal
  )

## nominal variables (unordered categories as factors)
train_df <- train_df %>%
  mutate(
    sex = factor(sex),               # Sex: 1 = Male, 2 = Female
    race = factor(race),             # Race/Ethnicity categories
    employ1 = factor(employ1),       # Employment status
    primins1 = factor(primins1),     # Primary insurance type
    numadult = as.numeric(numadult)  # # of adults in household (can leave as numeric)
  )

## check how values are coded
table(train_df$hlthpl1, useNA = "ifany")
```
################################ one-hot encoding train #######################################

```{r}

# Ensure categorical variables are factors BK
train_df <- train_df %>%
  mutate(
    hlthpl1 = factor(hlthpl1),
    persdoc3 = factor(persdoc3),
    medcost1 = factor(medcost1),
    checkup1 = factor(checkup1),
    primins1 = factor(primins1),
    addepev3 = factor(addepev3),
    acedeprs = factor(acedeprs),
    decide = factor(decide),
    exerany2 = factor(exerany2),
    pa150r4 = factor(pa150r4),
    sex = factor(sex),
    race = factor(race),
    educa = factor(educa),
    employ1 = factor(employ1),
    marital = factor(marital),
    incomg1 = factor(incomg1)
  )

# One-hot encode all factor variables
# Separate response variable
response_var <- train_df$ment14d

# Remove it temporarily from dataset to avoid encoding
brfss_train_no_response <- train_df %>% select(-ment14d)

# Encode predictors only
brfss_train_encoded <- fastDummies::dummy_cols(
  brfss_train_no_response,
  remove_first_dummy = TRUE,
  remove_selected_columns = TRUE
)

# Add response variable back
brfss_train_encoded$ment14d <- response_var
```

# Test Set Encoding
```{r}
# Clean variable names BK
test_df <- test_df %>% clean_names()

## binary variables (0=no, 1=yes)
test_df <- test_df %>%
  mutate(
    hlthpl1 = ifelse(hlthpl1 == 1, 1, 0),      # Health plan coverage
    persdoc3 = ifelse(persdoc3 == 1, 1, 0),    # Personal doctor
    medcost1 = ifelse(medcost1 == 1, 1, 0),    # Could not see doctor due to cost
    exerany2 = ifelse(exerany2 == 1, 1, 0),    # Physical activity
    addepev3 = ifelse(addepev3 == 1, 1, 0),    # Ever told you had depressive disorder
    acedeprs = ifelse(acedeprs == 1, 1, 0),    # ACE: depression exposure
    decide = ifelse(decide == 1, 1, 0),        # Decision-making difficulty (cognitive decline)
    pa150r4 = ifelse(pa150r4 == 1, 1, 0)       # Met physical activity guidelines
  )

## ordinal variables (ordered factor)
test_df <- test_df %>%
  mutate(
    educa = factor(educa, levels = c(1:6), ordered = TRUE),            # Education level
    incomg1 = factor(incomg1, levels = 1:8, ordered = TRUE),           # Income group
    checkup1 = factor(checkup1, levels = c(4,3,2,1), ordered = TRUE),  # Last checkup (4 = Never → 1 = <1 year)
    marital = factor(marital, levels = c(5,6,3,4,1,2), ordered = TRUE),# Marital status, loosely ordered
    age80 = as.numeric(age80)                                          # Continuous, but sometimes treated as ordinal
  )

## nominal variables (unordered categories as factors)
test_df <- test_df %>%
  mutate(
    sex = factor(sex),               # Sex: 1 = Male, 2 = Female
    race = factor(race),             # Race/Ethnicity categories
    employ1 = factor(employ1),       # Employment status
    primins1 = factor(primins1),     # Primary insurance type
    numadult = as.numeric(numadult)  # # of adults in household (can leave as numeric)
  )

## check how values are coded
table(test_df$hlthpl1, useNA = "ifany")
```
################################ one-hot encoding test #######################################

```{r}
# Ensure categorical variables are factors BK
test_df <- test_df %>%
  mutate(
    hlthpl1 = factor(hlthpl1),
    persdoc3 = factor(persdoc3),
    medcost1 = factor(medcost1),
    checkup1 = factor(checkup1),
    primins1 = factor(primins1),
    addepev3 = factor(addepev3),
    acedeprs = factor(acedeprs),
    decide = factor(decide),
    exerany2 = factor(exerany2),
    pa150r4 = factor(pa150r4),
    sex = factor(sex),
    race = factor(race),
    educa = factor(educa),
    employ1 = factor(employ1),
    marital = factor(marital),
    incomg1 = factor(incomg1)
  )

# One-hot encode all factor variables
# Separate response variable
response_var_test <- test_df$ment14d

# Remove it temporarily from dataset to avoid encoding
brfss_test_no_response <- test_df %>% select(-ment14d)

# Encode predictors only
brfss_test_encoded <- fastDummies::dummy_cols(
  brfss_test_no_response,
  remove_first_dummy = TRUE,
  remove_selected_columns = TRUE
)

# Add response variable back
brfss_test_encoded$ment14d <- response_var_test

missing_cols <- setdiff(colnames(brfss_train_encoded), colnames(brfss_test_encoded))
print(missing_cols)

for (col in missing_cols) {
  brfss_test_encoded[[col]] <- 0
}

brfss_test_encoded <- brfss_test_encoded[, colnames(brfss_train_encoded)]
```

# Encode Train Variables - BK
#```{r}
#encodeTrain <- dummy_cols(train_df, #Select multilevel Nominal predictors for encoding
#                       select_columns = c("race", "primins1", "employ1",
#                                          "marital", "incomg1", "state"),
#                       remove_first_dummy = TRUE, #Avoids dummy variable trap
#                       remove_selected_columns = TRUE) #Removes original, un-encoded columns
#```
# Encode Test Variables - BK
#```{r}
#encodeTest <- dummy_cols(test_df, 
#                       select_columns = c("race", "primins1", "employ1",
#                                          "marital", "incomg1", "state"),
#                       remove_first_dummy = TRUE, 
#                       remove_selected_columns = TRUE)
#```


# Impute Missing Values - CR and SS
```{r}
#Impute Train
predMatrix <- quickpred(brfss_train_encoded, mincor = 0.2) #Create Prediction matrix to only use variables for comparison with correlation greater than 0.2

set.seed(123)
imputedTrain <- parlmice(brfss_train_encoded, #parlmice to introduce parallel processing
                         m = 1, 
                         method = "pmm", #PMM made sense given encoding. Fits regression model, and then estimates predicted values using random sampling from matched values.
                         maxit = 8,
                         predictorMatrix = predMatrix,
                         n.core = 4,
                         n.imp.core = 1)
plot(imputedTrain)
trainimputeFinal <- complete(imputedTrain)
trainimputeFinal$ment14d <- train_df$ment14d

#Impute Test
set.seed(123)
imputedTest <- parlmice(brfss_test_encoded, 
                         m = 1, 
                         method = "pmm", 
                         maxit = 8,
                         predictorMatrix = predMatrix,
                         n.core = 4,
                         n.imp.core = 1)
plot(imputedTest)
testimputeFinal <- complete(imputedTest)
testimputeFinal$ment14d <- test_df$ment14d
```
##########################################################################New Code for Initial Modeling############################################################################################################

## Creating Categorical Target Variable ('ment14d_cat')- CR
```{r}
trainimputeFinal <- trainimputeFinal %>%
  mutate(ment14d_cat = case_when(
    ment14d == 1 ~ "None",         # 0 days
    ment14d == 2 ~ "Occasional",   # 1–13 days
    ment14d == 3 ~ "Frequent",     # 14+ days
    TRUE ~ NA_character_
  ))

testimputeFinal <- testimputeFinal %>%
  mutate(ment14d_cat = case_when(
    ment14d == 1 ~ "None",
    ment14d == 2 ~ "Occasional",
    ment14d == 3 ~ "Frequent",
    TRUE ~ NA_character_
  ))

trainimputeFinal$ment14d_cat <- factor(trainimputeFinal$ment14d_cat, levels = c("None", "Occasional", "Frequent"))
testimputeFinal$ment14d_cat <- factor(testimputeFinal$ment14d_cat, levels = c("None", "Occasional", "Frequent"))
```


```{r}
train_clean <- trainimputeFinal %>%
  mutate(across(where(is.integer), as.numeric)) %>%
  select(-ment14d)  # Remove the original numeric target to prevent leakage

test_clean <- testimputeFinal %>%
  mutate(across(where(is.integer), as.numeric)) %>%
  select(-ment14d)
```


# Tidymodels Recipe for Scaling/Centering - SS
```{r}
recipe <- recipe(ment14d_cat ~ ., data = train_clean) %>%  # Use cleaned training data
  update_role(menthlth, starts_with("addepev3"), starts_with("acedeprs"), starts_with("decide"), new_role = "id") %>%
  step_center(all_numeric_predictors()) %>%
  step_scale(all_numeric_predictors())

preparedRecipe <- prep(recipe, training = train_clean)

traindataFinal <- bake(preparedRecipe, new_data = train_clean)
testdataFinal <- bake(preparedRecipe, new_data = test_clean)

dim(traindataFinal)
dim(testdataFinal)
head(traindataFinal)
```



## Principle Component Analysis (PCA) on Scaled Data - CR
```{r}
pca_input_data <- traindataFinal %>%
  filter(if_all(everything(), ~ !is.na(.) & is.finite(.))) # Filter out rows with any NA or infinite values

pca_input <- pca_input_data %>% 
  select(where(is.numeric)) %>% # Keep only numeric columns for PCA
  scale() # Standardize numeric features

pca_result <- prcomp(pca_input, center = TRUE, scale. = TRUE) #PCA with centering and scaling

plot(pca_result, type = "l", main = "Scree Plot") #Visualize variance by each principle component
summary(pca_result) #Output cumulative variance to decide how many components to retain
```

```{r}
pca_scores <- as.data.frame(pca_result$x) # Get PCA scores
pca_scores$ment14d_cat <- pca_input_data$ment14d_cat # Add original outcome category to PCA scores
```

```{r}
library(ggplot2)

ggplot(pca_scores, aes(x = PC1, y = PC2, color = ment14d_cat)) +
  geom_point(alpha = 0.5) +
  labs(title = "PCA: PC1 vs PC2 colored by ment14d_cat") +
  theme_minimal()
```

```{r}
set.seed(123)
kmeans_result <- kmeans(pca_scores[, 1:2], centers = 3)  # Using PC1 & PC2 # Run k-means clustering with k = 3 on PC1 & PC2

pca_scores$cluster <- as.factor(kmeans_result$cluster) # Assign labels
```

```{r}
ggplot(pca_scores, aes(x = PC1, y = PC2, color = cluster)) +
  geom_point(alpha = 0.5) +
  labs(title = "K-means Clusters (k=3) on PCA Components") +
  theme_minimal()
```

```{r}
table(Actual = pca_scores$ment14d_cat, Cluster = pca_scores$cluster) # Compare clusters to original categories


############################################### Modeling ########################################################


```{r}
library(nnet) # Load for multinomial logistic regression
```

```{r}
multi_model <- multinom_reg(mode = "classification") %>% # Set up multinomial logistic model
  set_engine("nnet")
```

```{r}
multi_wf <- workflow() %>% # Create workflow with recipe and multinomial model
  add_model(multi_model) %>%
  add_recipe(recipe)
```

```{r}
multi_fit <- fit(multi_wf, data = traindataFinal) # Fit model using preprocessed training data
```

```{r}
multi_preds <- predict(multi_fit, new_data = testdataFinal) # Predict class labels for test set
```

```{r}
multi_probs <- predict(multi_fit, new_data = testdataFinal, type = "prob") # Predict class probabilities
```

```{r}
test_results <- bind_cols(testdataFinal, multi_preds) %>% # Combine predictions with test set
  rename(pred_class = .pred_class) # Rename predicted class
```

```{r}
accuracy(test_results, truth = ment14d_cat, estimate = pred_class) # Calculate classification accuracy on test set
```

```{r}
conf_mat(test_results, truth = ment14d_cat, estimate = pred_class) # Confusion matrix to evaluate prediction breakdown across categories
```
```{r}
set.seed(123)
folds <- vfold_cv(train_clean, v = 5, strata = ment14d_cat) # Create 5-fold cross validation with stratification on target variable

```

```{r}
multi_model <- multinom_reg(mode = "classification") %>% # Define multinomial logistic regression model for classification
  set_engine("nnet")

multi_wf <- workflow() %>% # Create workflow using formula interface with multinomial model
  add_model(multi_model) %>%
  add_formula(ment14d_cat ~ .)

```

```{r}
cv_results <- fit_resamples( # Perform 5-fold cross validation and save prediction
  multi_wf,
  resamples = folds,
  metrics = metric_set(yardstick::accuracy),
  control = control_resamples(save_pred = TRUE)
)

```

```{r}
collect_metrics(cv_results) # Mean accuracy across cross validation folds

```

```{r}
library(ranger) # Fast Random Forest engine
```

```{r}
rf_model <- rand_forest( # Set up model with hyperparameters to tune
  mode = "classification",
  mtry = tune(),
  trees = 100,
  min_n = tune()
) %>%
  set_engine("ranger", importance = "impurity") # Define Random Forest classification model using ranger engine
```

```{r}
rf_wf <- workflow() %>% # Create workflow with preprocessing recipe and Random Forest model
  add_model(rf_model) %>%
  add_recipe(recipe)
```

```{r}
set.seed(123) # Set up 5-fold cross-validation with stratified sampling on outcome
folds <- vfold_cv(train_clean, v = 5, strata = ment14d_cat) 
```

```{r}
rf_results <- tune_grid( # Tune mtry and min_n using cross-validation
  rf_wf,
  resamples = folds,
  grid = 3,
  metrics = metric_set(yardstick::accuracy),
  control = control_grid(verbose = TRUE)
)
```

```{r}
saveRDS(rf_results, "rf_results.rds")
```

```{r}
file.info("rf_results.rds")
```


```{r}
best_rf <- select_best(x = rf_results, metric = "accuracy")  # Select hyperparameters with highest accuracy
```

```{r}
rf_model_final <- rand_forest(
  mode = "classification",
  mtry = best_rf$mtry,
  trees = 100,
  min_n = best_rf$min_n
) %>%
  set_engine("ranger", importance = "impurity")
```

```{r}
final_rf_wf <- workflow() %>%
  add_model(rf_model_final) %>%
  add_recipe(recipe)
```


```{r}
final_rf_wf <- finalize_workflow(rf_wf, best_rf) # Finalize the workflow with best hyperparameters and fit on full training data

final_rf_fit <- fit(final_rf_wf, data = traindataFinal)
```

```{r}
rf_preds <- predict(final_rf_fit, new_data = testdataFinal) # Predict classes on test set using finalized Random Forest model

rf_probs <- predict(final_rf_fit, new_data = testdataFinal, type = "prob") # Predict probabilities
```

```{r}
rf_results_final <- bind_cols(testdataFinal, rf_preds) %>% # Combine predictions with test set
  rename(pred_class = .pred_class)

accuracy(rf_results_final, truth = ment14d_cat, estimate = pred_class) # Accuracy

conf_mat(rf_results_final, truth = ment14d_cat, estimate = pred_class) # Confusion matrix
```

```{r}
final_rf_fit %>% # Show variable importance
  extract_fit_parsnip() %>% 
  vip::vip(num_features = 15)
```
